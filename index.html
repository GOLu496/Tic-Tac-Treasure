<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<style>
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    background: transparent;
    overflow: hidden;
  }
  body {
    display: flex;
    justify-content: center;
    align-items: center;
    font-family: Arial, sans-serif;
  }
  .big-square {
    position: relative;
    width: 400px;
    height: 400px;
    background: transparent; /* fully transparent */
    border-radius: 15px;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  #board {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    grid-template-rows: repeat(3, 1fr);
    gap: 0;
    width: 90%;
    height: 90%;
    background: transparent;
    visibility: hidden; /* start tak hidden */
    border: 2px solid black; /* outer border visible */
  }
  .cell {
    background: transparent;
    border: 1px solid black; /* grid lines only */
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    user-select: none;
    box-sizing: border-box;
  }
  .cell img {
    width: 100%;
    height: 100%;
    object-fit: contain;
    pointer-events: none;
    background: transparent;
  }
  #menu {
    background: transparent;
    text-align: center;
    width: 100%;
  }
  .mode-bot {
    border: none;
    background: transparent;
    cursor: pointer;
    width: 50vw;
    max-width: 400px;
    height: 20vh;
    padding: 0;
  }
  .mode-bot img {
    width: 100%;
    height: 100%;
    object-fit: contain;
    pointer-events: none;
    display: block;
    background: transparent;
  }
  #winnerScreen {
    display: none;
    background: transparent;
    color: transparent; /* hide text */
    text-align: center;
  }
  #winnerText {
    color: transparent; /* hide text */
  }
  #restartBtn {
    cursor: pointer;
    border: none;
    background: transparent;
    width: 150px;
    height: 60px;
    padding: 0;
    display: none; /* initially hidden */
  }
  #restartBtn img {
    width: 100%;
    height: 100%;
    object-fit: contain;
    pointer-events: none;
    background: transparent;
    display: block;
  }
</style>
</head>
<body>

<div class="big-square">
  <div id="board">
    <div class="cell" data-index="0"></div>
    <div class="cell" data-index="1"></div>
    <div class="cell" data-index="2"></div>
    <div class="cell" data-index="3"></div>
    <div class="cell" data-index="4"></div>
    <div class="cell" data-index="5"></div>
    <div class="cell" data-index="6"></div>
    <div class="cell" data-index="7"></div>
    <div class="cell" data-index="8"></div>
  </div>

  <div id="menu">
    <button class="mode-bot" id="startBtn">
      <img src="1.jpg" alt="start" />
    </button>
  </div>

  <div id="winnerScreen">
    <h2 id="winnerText"></h2>
    <button id="restartBtn" onclick="window.location.href='https://www.google.com'">
      <img src="2.jpg" alt="restart" />
    </button>
  </div>
</div>

<script>
let gameMode = null;
let turn = "X";
let gameOver = false;

let xOrder = [];
let oOrder = [];

let tokenImages = {
  X: localStorage.getItem("tokenX") || null,
  O: localStorage.getItem("tokenO") || null,
};

const defaultImages = {
  X: "https://github.com/GOLu496/Tic-Tac-Toe/blob/main/2.jpg",
  O: "/data/data/com.termux/files/home/tictactoe/2.jpg",
};

const winPatterns = [
  [0,1,2],[3,4,5],[6,7,8],
  [0,3,6],[1,4,7],[2,5,8],
  [0,4,8],[2,4,6]
];

document.getElementById("startBtn").addEventListener("click", () => {
  gameMode = "bot";
  document.getElementById("menu").style.display = "none";
  document.getElementById("board").style.visibility = "visible";
  document.getElementById("winnerScreen").style.display = "none";
  document.getElementById("restartBtn").style.display = "none";
});

function showWinner(symbol) {
  gameOver = true;
  document.getElementById("board").style.visibility = "hidden";
  document.getElementById("winnerText").textContent = `Winner: ${symbol}`;
  document.getElementById("winnerScreen").style.display = "block";
  document.getElementById("restartBtn").style.display = "inline-block";

  if(window.Kodular && typeof window.Kodular.setWebViewString === "function") {
    window.Kodular.setWebViewString("winner:" + symbol);
  }
}

function clearBoard() {
  const cells = document.querySelectorAll(".cell");
  cells.forEach(c => {
    c.innerHTML = "";
    c.removeAttribute("data-symbol");
  });
  xOrder = [];
  oOrder = [];
  turn = "X";
  gameOver = false;
  document.querySelectorAll(".win-line").forEach(line => line.remove());
}

function placeSymbol(cell, symbol) {
  const idx = +cell.getAttribute("data-index");
  if(cell.dataset.symbol) return false;

  const img = document.createElement("img");
  img.src = tokenImages[symbol] || defaultImages[symbol];
  cell.innerHTML = "";
  cell.appendChild(img);
  cell.dataset.symbol = symbol;

  if(symbol === "X") {
    xOrder.push(idx);
    if(xOrder.length > 3){
      const rem = xOrder.shift();
      const rc = document.querySelector(`.cell[data-index="${rem}"]`);
      if(rc) {
        rc.innerHTML = "";
        rc.removeAttribute("data-symbol");
      }
    }
  } else {
    oOrder.push(idx);
    if(oOrder.length > 3){
      const rem = oOrder.shift();
      const rc = document.querySelector(`.cell[data-index="${rem}"]`);
      if(rc) {
        rc.innerHTML = "";
        rc.removeAttribute("data-symbol");
      }
    }
  }
  return true;
}

function getBoardArr() {
  return [...document.querySelectorAll(".cell")].map(c => c.dataset.symbol || null);
}

function checkWinnerFromBoardArr(arr) {
  for(const p of winPatterns) {
    const [a,b,c] = p;
    if(arr[a] && arr[a] === arr[b] && arr[a] === arr[c]) return arr[a];
  }
  return null;
}

function drawWinningLine(pattern) {
  const board = document.getElementById("board");
  const cells = document.querySelectorAll(".cell");
  const rectA = cells[pattern[0]].getBoundingClientRect();
  const rectC = cells[pattern[2]].getBoundingClientRect();
  const boardRect = board.getBoundingClientRect();
  const x1 = rectA.left + rectA.width / 2 - boardRect.left;
  const y1 = rectA.top + rectA.height / 2 - boardRect.top;
  const x2 = rectC.left + rectC.width / 2 - boardRect.left;
  const y2 = rectC.top + rectC.height / 2 - boardRect.top;
  const line = document.createElement("div");
  line.classList.add("win-line");
  line.style.width = Math.hypot(x2-x1, y2-y1) + "px";
  line.style.transform = `translate(${x1}px,${y1}px) rotate(${Math.atan2(y2-y1,x2-x1)}rad)`;
  board.appendChild(line);
}

function checkWinnerUI() {
  const winner = checkWinnerFromBoardArr(getBoardArr());
  if(winner){
    const pattern = winPatterns.find(p => p.every(i => getBoardArr()[i] === winner));
    if(pattern) drawWinningLine(pattern);
    setTimeout(() => showWinner(winner), 600);
    return true;
  }
  return false;
}

document.querySelectorAll(".cell").forEach(cell => {
  cell.addEventListener("click", () => {
    if(gameOver) return;
    if(!placeSymbol(cell, turn)) return;

    if(checkWinnerUI()) return;

    if(gameMode === "bot" && turn === "X") {
      turn = "O";
      setTimeout(botMove, 250);
    } else {
      turn = (turn === "X") ? "O" : "X";
    }
  });
});

// Bot and game logic unchanged
const MAX_DEPTH = 10;
function botMove() {
  if(gameOver) return;
  const state = readState();
  let bestScore = -Infinity;
  let bestIdx = null;
  const legal = legalPlacements(state, "O");
  for(const idx of legal) {
    const next = applyPlacement(state, idx, "O");
    const score = minimax(next, 1, -Infinity, Infinity, false);
    if(score > bestScore) {
      bestScore = score;
      bestIdx = idx;
    }
  }
  if(bestIdx !== null) {
    const cell = document.querySelector(`.cell[data-index="${bestIdx}"]`);
    placeSymbol(cell, "O");
    if(checkWinnerUI()) return;
    turn = "X";
  }
}
function readState() {
  const board = getBoardArr();
  return {
    board,
    xOrder: [...xOrder],
    oOrder: [...oOrder]
  };
}
function legalPlacements(state, who) {
  const res = [];
  for(let i=0; i<9; i++) if(state.board[i]==null) res.push(i);
  return res;
}
function applyPlacement(state, idx, who) {
  const board = state.board.slice();
  const xQ = state.xOrder.slice();
  const oQ = state.oOrder.slice();
  if(board[idx] != null) return state;
  board[idx] = who;
  if(who === "X") {
    xQ.push(idx);
    if(xQ.length > 3) {
      const rem = xQ.shift();
      board[rem] = null;
    }
  } else {
    oQ.push(idx);
    if(oQ.length > 3) {
      const rem = oQ.shift();
      board[rem] = null;
    }
  }
  return { board, xOrder: xQ, oOrder: oQ };
}
function terminalScore(board, depth) {
  const w = checkWinnerFromBoardArr(board);
  if(w === "O") return 100 - depth;
  if(w === "X") return depth - 100;
  return null;
}
function heuristic(board) {
  let score = 0;
  for(const p of winPatterns) {
    const [a,b,c] = p;
    const line = [board[a], board[b], board[c]];
    const o = line.filter(v => v === "O").length;
    const x = line.filter(v => v === "X").length;
    const e = 3 - o - x;
    if(o > 0 && x > 0) continue;
    if(o === 2 && e === 1) score += 6;
    else if(o === 1 && e === 2) score += 2;
    else if(x === 2 && e === 1) score -= 6;
    else if(x === 1 && e === 2) score -= 2;
  }
  if(board[4] === "O") score += 1;
  else if(board[4] === "X") score -= 1;
  [0, 2, 6, 8].forEach(i => {
    if(board[i] === "O") score += 0.5;
    else if(board[i] === "X") score -= 0.5;
  });
  return score;
}
function minimax(state, depth, alpha, beta, maximizing) {
  const term = terminalScore(state.board, depth);
  if(term !== null) return term;
  if(depth >= MAX_DEPTH) return heuristic(state.board);
  if(maximizing) {
    let best = -Infinity;
    const moves = legalPlacements(state, "O");
    for(const idx of moves) {
      const next = applyPlacement(state, idx, "O");
      const val = minimax(next, depth + 1, alpha, beta, false);
      best = Math.max(best, val);
      alpha = Math.max(alpha, val);
      if(beta <= alpha) break;
    }
    return best;
  } else {
    let best = Infinity;
    const moves = legalPlacements(state, "X");
    for(const idx of moves) {
      const next = applyPlacement(state, idx, "X");
      const val = minimax(next, depth + 1, alpha, beta, true);
      best = Math.min(best, val);
      beta = Math.min(beta, val);
      if(beta <= alpha) break;
    }
    return best;
  }
}
</script>

</body>
</html>
